<?php

/**
 * @file
 * Adds Entity Translation support to the Search API.
 */

/**
 * Implements hook_search_api_item_type_info().
 *
 * Provides a multilingual version of all entity types.
 */
function search_api_et_search_api_item_type_info() {
  $types = array();

  foreach (entity_get_property_info() as $type => $property_info) {
    if (($info = entity_get_info($type)) && field_has_translation_handler($type)) {
      $types["search_api_et_$type"] = array(
        'name' => t('!type (multilingual)', array('!type' => $info['label'])),
        'datasource controller' => 'SearchApiEtDatasourceController',
        'entity_type' => $type,
      );
    }
  }

  return $types;
}

/**
 * Implements search_api_index_update().
 */
function search_api_et_search_api_index_update(SearchApiIndex $index) {
  // On feature reverts, the index's numerical ID might change. In that case,
  // we need to keep the {search_api_et_item} table up to date.
  if ($index->id != $index->original->id) {
    db_update('search_api_et_item')
      ->fields(array('index_id' => $index->id))
      ->condition('index_id', $index->original->id)
      ->execute();
  }
}

/**
 * Retrieve the Search API ET settings for a specific index.
 *
 * @param SearchApiIndex $index
 *   The index whose settings should be retrieved.
 *
 * @return array
 *   An associative array with the Search API ET settings for the specified
 *   index. The settings are as follows:
 *   - languages: All languages which should be included in the index.
 *   - include: Determines with which languages an item should be included in
 *     the index. Possible values are:
 *     - all: Include items in all enabled languages, even if they don't have a
 *       translation.
 *     - incomplete: Include languages which have at least one translated fields
 *       on the entity.
 *     - complete: Only include entities for which all translatable fields have
 *       been translated.
 *   - fallback language: The language to be used for fields if the field isn't
 *     available in the target language. If NULL, fields without appropriate
 *     translations are removed.
 */
function search_api_et_get_index_settings(SearchApiIndex $index) {
  $settings = isset($index->options['search_api_et']) ? $index->options['search_api_et'] : array();
  $settings += array(
    // @todo Use only enabled languages?
    'languages' => array_keys(language_list()),
    'include' => 'all',
    'fallback language' => NULL,
  );
  return $settings;
}

/**
 * Determines the languages that are available for an entity in a certain index.
 *
 * @param object $entity
 *   The entity for which languages should be determined.
 * @param string $type
 *   The entity type of the entity.
 * @param SearchApiIndex $index
 *   The index whose settings should be used for determining the languages.
 *
 * @return array
 *   An array of language codes for the languages that are available.
 */
function search_api_et_item_languages($entity, $type, SearchApiIndex $index) {
  $settings = search_api_et_get_index_settings($index);
  if ($settings['include'] == 'all') {
    return $settings['languages'];
  }
  list(, , $bundle) = entity_extract_ids($type, $entity);
  $languages = array();
  $field_count = 0;
  foreach (field_info_instances($type, $bundle) as $field_name => $instance) {
    $field = field_info_field($field_name);
    if (!empty($field['translatable']) && isset($entity->{$instance['field_name']})) {
      ++$field_count;
      foreach ($entity->{$instance['field_name']} as $lang => $data) {
        $languages += array($lang => 0);
        ++$languages[$lang];
      }
    }
  }
  if ($settings['include'] == 'complete') {
    foreach ($languages as $lang => $count) {
      if ($count < $field_count) {
        unset($languages[$lang]);
      }
    }
  }
  return array_keys($languages);
}

/**
 * Implements hook_entity_translation_insert().
 */
function search_api_et_entity_translation_insert($entity_type, $entity, $translation, $values = array()) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  $item_id = $translation['language'] . '_' . $entity_id;
  search_api_track_item_insert('search_api_et_' . $entity_type, array($item_id));
}

/**
 * Implements hook_entity_translation_update().
 */
function search_api_et_entity_translation_update($entity_type, $entity, $translation, $values = array()) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  $item_id = $translation['language'] . '_' . $entity_id;
  search_api_track_item_change('search_api_et_' . $entity_type, array($item_id));
}

/**
 * Implements hook_entity_translation_delete().
 */
function search_api_et_entity_translation_delete($entity_type, $entity, $langcode) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  $item_id = $langcode . '_' . $entity_id;
  search_api_track_item_delete('search_api_et_' . $entity_type, array($item_id));
}

/**
 * Implements hook_features_export_alter().
 *
 * Adds dependency information for relevant exported indexes.
 */
function search_api_et_features_export_alter(&$export, $module_name) {
  if (isset($export['features']['search_api_index'])) {
    // Check all of the exported index definitions.
    foreach ($export['features']['search_api_index'] as $index_name) {
      $indexes = search_api_index_load_multiple(FALSE, array('machine_name' => $index_name));
      $index = reset($indexes);
      $controller = search_api_get_datasource_controller($index->item_type);
      if ($controller instanceof SearchApiEtDatasourceController) {
        if (!isset($export['dependencies']['search_api_et'])) {
          $export['dependencies']['search_api_et'] = 'search_api_et';
        }
      }
    }
    // Ensure the dependencies list is still sorted alphabetically.
    ksort($export['dependencies']);
  }
}
